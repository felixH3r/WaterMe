{"version":3,"file":"carousel.component.js","sources":["../../src/carousel/carousel.component.ts"],"names":[],"mappings":"AAAA,sBAAsB;AACtB,OAcO,EAAE,SAAS,EAAE,KAAK,EAAa,MAAM,EAAE,YAAY,EAAE,MAAM,eAAe;AACjF,OACO,EAAE,KAAK,EAAE,UAAU,EAAE,MAAM,UAAU;AAC5C,OACO,EAAE,cAAc,EAAE,MAAM,mBAAmB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAElD,WAAY,SAA+B;AAA3C,WAAY,SAAS;AAAI,IAAF,+CAAO,CAAA;AAAC,IAAC,yCAAI,CAAA;AAAC,IAAC,yCAAI,CAAA;AAAA,CAAC,EAA/B,SAAS,KAAT,SAAS,QAAsB;AAE3C;AACA;AACA,GAAG;AAEH;AAA8C,IAiD5C,2BAAmB,MAAsB;AAC3C,QA1CE,4GAA4G;AAC9G,QAAU,sBAAiB,GAAuB,IAAI,YAAY,CAAM,KAAK,CAAC,CAAC;AAC/E,QA0BY,YAAO,GAA+B,IAAI,UAAU,EAAkB,CAAC;AACnF,QAMY,cAAS,GAAY,KAAK,CAAC;AACvC,QAMI,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;AAChC,IAAE,CAAC;AACH,IAvCE,sBAAW,0CAAW;AAAI,aAK1B;AAAc,YACZ,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC;AACpC,QAAE,CAAC;AAEH,QAXE,wDAAwD;AAC1D,aACE,UAAuB,KAAa;AACtC,YAAI,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,KAAK,KAAK,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC;AACpE,gBAAM,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AAC1B,YAAI,CAAC;AACL,QAAE,CAAC;AACF;AAA0B;AACV,OAFd;AACH,IAUE,sBAAW,uCAAQ;AAAI,QAJvB;AACF;AAEA,WADK;AACL,aACE;AAAc,YACZ,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC;AAC1B,QAAE,CAAC;AACF,aAAC,UAAoB,KAAa;AACnC,YAAI,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;AAC3B,YAAI,IAAI,CAAC,YAAY,EAAE,CAAC;AACxB,QAAE,CAAC;AAEH;AAA0B;AAA2B,OANlD;AACH,IAME,sBAAW,qCAAM;AAAI,aAArB;AAAc,YACZ,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;AAClC,QAAE,CAAC;AAEH;AAA0B;AACP,OAHhB;AACH,IAKE,sBAAW,oCAAK;AAAI,aAApB;AAAc,YACZ,MAAM,CAAC,CAAC,KAAK,EAAE,CAAC;AACpB,QAAE,CAAC;AAEH;AAA0B;AACpB,OAHH;AACH,IAKS,uCAAW,GAAlB;AAAc,QACZ,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;AAC1B,IAAE,CAAC;AAEH,IAAE;AACF;AACE;AACE,OAAC;AACL,IAAS,oCAAQ,GAAf,UAAgB,KAAqB;AAAI,QACvC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AAC5B,QAAI,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;AACpC,YAAM,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC,CAAC;AACxC,YAAM,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;AAC3B,YAAM,IAAI,CAAC,IAAI,EAAE,CAAC;AAClB,QAAI,CAAC;AACL,IAAE,CAAC;AAEH,IAAE;AACF;AACE;AACE,OAAC;AACL,IAAS,uCAAW,GAAlB,UAAmB,KAAqB;AAAI,QAA5C,iBA6BC;AACH,QA7BI,IAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AACjD,QACI,EAAE,CAAC,CAAC,IAAI,CAAC,mBAAmB,KAAK,QAAQ,CAAC,CAAC,CAAC;AAChD,YACM,2BAA2B;AACjC,YAAM,IAAI,gBAAc,GAAW,KAAK,CAAC,CAAC;AAC1C,YAAM,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;AACpC,gBAAQ,2GAA2G;AACnH,gBAAQ,yFAAyF;AACjG,gBAAQ,gBAAc,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,QAAQ;AAC1D,oBAAU,IAAI,CAAC,MAAM,GAAG,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;AACzC,YAAM,CAAC;AACP,YAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AACpC,YACM,6DAA6D;AACnE,YAAM,UAAU,CAAC;AACX,gBAAE,KAAI,CAAC,OAAO,CAAC,gBAAc,CAAC,CAAC;AACrC,YAAM,CAAC,EAAE,CAAC,CAAC,CAAC;AACZ,QAAI,CAAC;AAAC,QAAA,IAAI,CAAC,CAAC;AACZ,YAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AACpC,YAAM,IAAM,mBAAiB,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;AAC5D,YAAM,UAAU,CAAC;AACX,gBAAE,kEAAkE;AAC1E,gBAAQ,KAAI,CAAC,mBAAmB,GAAG,mBAAiB,CAAC;AACrD,gBAAQ,KAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAI,CAAC,mBAAmB,CAAC,CAAC;AAC9D,YAAM,CAAC,EAAE,CAAC,CAAC,CAAC;AACZ,QACI,CAAC;AACL,IAAE,CAAC;AAEH,IAAE;AACF;AACE;AACE,OAAC;AACL,IAAS,qCAAS,GAAhB,UAAiB,KAAsB;AAAI,QAA1B,qBAAsB,GAAtB,aAAsB;AAAI,QACzC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACtE,IAAE,CAAC;AAEH,IAAE;AACF;AACE;AACE,OAAC;AACL,IAAS,yCAAa,GAApB,UAAqB,KAAsB;AAAI,QAA1B,qBAAsB,GAAtB,aAAsB;AAAI,QAC7C,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACtE,IAAE,CAAC;AAEH,IAAE;AACF;AACE;AACE,OAAC;AACL,IAAS,uCAAW,GAAlB,UAAmB,KAAa;AAAI,QAClC,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;AAC7B,IAAE,CAAC;AAEH,IAAE;AACF;AACE,OAAG;AACL,IAAS,gCAAI,GAAX;AAAc,QACZ,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;AAC1B,YAAM,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;AAC5B,YAAM,IAAI,CAAC,YAAY,EAAE,CAAC;AAC1B,QAAI,CAAC;AACL,IAAE,CAAC;AAEH,IAAE;AACF;AACE,OAAG;AACL,IAAS,iCAAK,GAAZ;AAAc,QACZ,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;AACxB,YAAM,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;AAC7B,YAAM,IAAI,CAAC,UAAU,EAAE,CAAC;AACxB,QAAI,CAAC;AACL,IAAE,CAAC;AAEH,IAAE;AACF;AACE;AACE,OAAC;AACL,IAAS,gDAAoB,GAA3B;AAAc,QACZ,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,UAAC,KAAqB,IAAK,OAAA,KAAK,CAAC,MAAM,EAAZ,CAAY,CAAC,CAAC;AAC3E,IAAE,CAAC;AAEH,IAAE;AACF;AACE;AACE;AAEJ,OADK;AACL,IAAS,kCAAM,GAAb,UAAc,KAAa;AAAI,QAC7B,MAAM,CAAC,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;AAC5C,IAAE,CAAC;AAEH,IAAE;AACF;AACE;AACE;AACE;AAEJ,OADG;AACL,IAAU,8CAAkB,GAA1B,UAA2B,SAAoB,EAAE,KAAc;AAAI,QACjE,IAAI,cAAc,GAAW,CAAC,CAAC;AACnC,QACI,EAAE,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,SAAS,KAAK,SAAS,CAAC,IAAI,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACnG,YAAM,MAAM,CAAC,KAAK,CAAC,CAAC;AACpB,QAAI,CAAC;AACL,QACI,MAAM,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;AACxB,YAAM,KAAK,SAAS,CAAC,IAAI;AACzB,gBAAQ,oHAAoH;AAC5H,gBAAQ,cAAc,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC,GAAG,IAAI,CAAC,mBAAmB,GAAG,CAAC;AAChG,oBAAU,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM,CAAE,GAAG,IAAI,CAAC,mBAAmB,GAAG,CAAC,CAAC;AAClE,gBAAQ,KAAK,CAAC;AACd,YAAM,KAAK,SAAS,CAAC,IAAI;AACzB,gBAAQ,sHAAsH;AAC9H,gBAAQ,cAAc,GAAG,CAAC,IAAI,CAAC,mBAAmB,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,mBAAmB,GAAG,CAAC;AACtF,oBAAU,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM,CAAE,GAAG,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;AACxF,gBAAQ,KAAK,CAAC;AACd,YAAM;AACN,gBAAQ,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;AAC7C,QAAI,CAAC;AACL,QAAI,MAAM,CAAC,cAAc,CAAC;AAC1B,IAAE,CAAC;AAEH,IAAE;AACF;AACE;AACE;AAEJ,OADK;AACL,IAAU,mCAAO,GAAf,UAAgB,KAAa;AAAI,QAC/B,EAAE,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AACvB,YAAM,IAAI,CAAC,KAAK,EAAE,CAAC;AACnB,YAAM,MAAM,CAAC;AACb,QAAI,CAAC;AACL,QAAI,IAAI,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;AAClE,QAAI,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;AACvB,YAAM,YAAY,CAAC,MAAM,GAAG,KAAK,CAAC;AAClC,QAAI,CAAC;AACL,QAAI,IAAI,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AAC5C,QAAI,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;AACpB,YAAM,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;AACvC,YAAM,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC;AAC9B,YAAM,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;AAC/B,YAAM,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACzC,QAAI,CAAC;AACL,IAAE,CAAC;AAEH,IAAE;AACF;AACE,OAAG;AACL,IAAU,wCAAY,GAApB;AAAc,QAAd,iBAeC;AACH,QAfI,IAAI,CAAC,UAAU,EAAE,CAAC;AACtB,QAAI,IAAI,QAAQ,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC;AAClC,QAAI,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC;AAC3C,YAAM,IAAI,CAAC,eAAe,GAAG,WAAW,CAChC;AACF,gBAAI,IAAI,SAAS,GAAG,CAAC,KAAI,CAAC,QAAQ,CAAC;AACzC,gBAAU,EAAE,CAAC,CAAC,KAAI,CAAC,SAAS,IAAI,CAAC,KAAK,CAAC,KAAI,CAAC,QAAQ,CAAC,IAAI,SAAS,GAAG,CAAC,IAAI,KAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;AAC/F,oBAAY,KAAI,CAAC,SAAS,EAAE,CAAC;AAC7B,gBAAU,CAAC;AAAC,gBAAA,IAAI,CAAC,CAAC;AAClB,oBAAY,KAAI,CAAC,KAAK,EAAE,CAAC;AACzB,gBAAU,CAAC;AACX,YAAQ,CAAC,EACD,QAAQ,CAAC,CAAC;AAClB,QAAI,CAAC;AACL,IAAE,CAAC;AAEH,IAAE;AACF;AACE,OAAG;AACL,IAAU,sCAAU,GAAlB;AAAc,QACZ,EAAE,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC;AAC/B,YAAM,aAAa,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;AAC1C,YAAM,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC,CAAC;AACpC,QAAI,CAAC;AACL,IAAE,CAAC,CAqBD;IApBK,JAqBP,IAAA,kBAAkB;SArBD,GAA0B,UAC3C,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,hDAqB1B,IAAO,gCAAc,GAAmE,cAAM,OAAA;QApB5F,QAAQ,EAAE,UAAU,5BAqBtB,QAAA,EAAC,IAAI,EAAE,cAAc,GAAG;AACxB,KAAC,EAF6F,CAE7F,CAAC;KArBA,QAAQ,EAAE,fAsBZ,IAAO,gCAAc,GAA2C;AAChE,QAAA,QAAQ,EAAE,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE;AAC5B,QAAA,SAAS,EAAE,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE;AAC7B,QAAA,mBAAmB,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,EAAE;AACxC,QAAA,aAAa,EAAE,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE;AACjC,QAAA,UAAU,EAAE,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE;AAC9B,KAAC;;gqBAbE,kBACF,EAAG,EAAE,OACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAWC;AACF,IAAA,wBAAC;AAAD,CAAC,AAxRD,IAwRC;AACD","sourcesContent":["// todo: add animation\n\n/***\n * pause (not yet supported) (?string='hover') - event group name which pauses the cycling of the carousel, if hover pauses on mouseenter and resumes on mouseleave\n keyboard (not yet supported) (?boolean=true) - if false carousel will not react to keyboard events\n note: swiping not yet supported\n */\n/****\n * Problems:\n * 1) if we set an active slide via model changes, .active class remains on a current slide.\n * 2) if we have only one slide, we shouldn't show prev/next nav buttons\n * 3) if first or last slide is active and noWrap is true, there should be \"disabled\" class on the nav buttons.\n * 4) default interval should be equal 5000\n */\n\nimport { Component, Input, OnDestroy, Output, EventEmitter } from '@angular/core';\n\nimport { isBs3, LinkedList } from '../utils';\nimport { SlideComponent } from './slide.component';\nimport { CarouselConfig } from './carousel.config';\n\nexport enum Direction {UNKNOWN, NEXT, PREV}\n\n/**\n * Base element to create carousel\n */\n\nexport class CarouselComponent implements OnDestroy {\n  /** If `true` — carousel will not cycle continuously and will have hard stops (prevent looping) */\n   public noWrap: boolean;\n  /**  If `true` — will disable pausing on carousel mouse hover */\n   public noPause: boolean;\n\n  protected _currentActiveSlide: number;\n\n  /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n   public activeSlideChange: EventEmitter <any> = new EventEmitter<any>(false);\n\n  /** Index of currently displayed slide(started for 0) */\n  \n  public set activeSlide(index: number) {\n    if (this._slides.length && index !== this._currentActiveSlide) {\n      this._select(index);\n    }\n  }\n  public get activeSlide(): number {\n    return this._currentActiveSlide;\n  }\n\n  protected _interval: number;\n\n  /**\n   * Delay of item cycling in milliseconds. If false, carousel won't cycle automatically.\n   */\n  \n  public get interval(): number {\n    return this._interval;\n  }\n  public set interval(value: number) {\n    this._interval = value;\n    this.restartTimer();\n  }\n\n  protected _slides: LinkedList<SlideComponent> = new LinkedList<SlideComponent>();\n  public get slides(): SlideComponent[] {\n    return this._slides.toArray();\n  }\n\n  protected currentInterval: any;\n  protected isPlaying: boolean;\n  protected destroyed: boolean = false;\n\n  public get isBs4():boolean {\n    return !isBs3();\n  }\n\n  public constructor(config: CarouselConfig) {\n    Object.assign(this, config);\n  }\n\n  public ngOnDestroy(): void {\n    this.destroyed = true;\n  }\n\n  /**\n   * Adds new slide. If this slide is first in collection - set it as active and starts auto changing\n   * @param slide\n   */\n  public addSlide(slide: SlideComponent): void {\n    this._slides.add(slide);\n    if (this._slides.length === 1) {\n      this._currentActiveSlide = void 0;\n      this.activeSlide = 0;\n      this.play();\n    }\n  }\n\n  /**\n   * Removes specified slide. If this slide is active - will roll to another slide\n   * @param slide\n   */\n  public removeSlide(slide: SlideComponent): void {\n    const remIndex = this._slides.indexOf(slide);\n\n    if (this._currentActiveSlide === remIndex) {\n\n      // removing of active slide\n      let nextSlideIndex: number = void 0;\n      if (this._slides.length > 1) {\n        // if this slide last - will roll to first slide, if noWrap flag is FALSE or to previous, if noWrap is TRUE\n        // in case, if this slide in middle of collection, index of next slide is same to removed\n        nextSlideIndex = !this.isLast(remIndex) ? remIndex :\n          this.noWrap ? remIndex - 1 : 0;\n      }\n      this._slides.remove(remIndex);\n\n      // prevents exception with changing some value after checking\n      setTimeout(() => {\n        this._select(nextSlideIndex);\n      }, 0);\n    } else {\n      this._slides.remove(remIndex);\n      const currentSlideIndex = this.getCurrentSlideIndex();\n      setTimeout(() => {\n        // after removing, need to actualize index of current active slide\n        this._currentActiveSlide = currentSlideIndex;\n        this.activeSlideChange.emit(this._currentActiveSlide);\n      }, 0);\n\n    }\n  }\n\n  /**\n   * Rolling to next slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  public nextSlide(force: boolean = false): void {\n    this.activeSlide = this.findNextSlideIndex(Direction.NEXT, force);\n  }\n\n  /**\n   * Rolling to previous slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  public previousSlide(force: boolean = false): void {\n    this.activeSlide = this.findNextSlideIndex(Direction.PREV, force);\n  }\n\n  /**\n   * Rolling to specified slide\n   * @param index: {number} index of slide, which must be shown\n   */\n  public selectSlide(index: number): void {\n    this.activeSlide = index;\n  }\n\n  /**\n   * Starts a auto changing of slides\n   */\n  public play(): void {\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      this.restartTimer();\n    }\n  }\n\n  /**\n   * Stops a auto changing of slides\n   */\n  public pause(): void {\n    if (!this.noPause) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n\n  /**\n   * Finds and returns index of currently displayed slide\n   * @returns {number}\n   */\n  public getCurrentSlideIndex(): number {\n    return this._slides.findIndex((slide: SlideComponent) => slide.active);\n  }\n\n  /**\n   * Defines, whether the specified index is last in collection\n   * @param index\n   * @returns {boolean}\n   */\n  public isLast(index: number): boolean {\n    return index + 1 >= this._slides.length;\n  }\n\n  /**\n   * Defines next slide index, depending of direction\n   * @param direction: Direction(UNKNOWN|PREV|NEXT)\n   * @param force: {boolean} if TRUE - will ignore noWrap flag, else will return undefined if next slide require wrapping\n   * @returns {any}\n   */\n  private findNextSlideIndex(direction: Direction, force: boolean): number {\n    let nextSlideIndex: number = 0;\n\n    if (!force && (this.isLast(this.activeSlide) && direction !== Direction.PREV && this.noWrap)) {\n      return void 0;\n    }\n\n    switch (direction) {\n      case Direction.NEXT:\n        // if this is last slide, not force, looping is disabled and need to going forward - select current slide, as a next\n        nextSlideIndex = (!this.isLast(this._currentActiveSlide)) ? this._currentActiveSlide + 1 :\n          (!force && this.noWrap ) ? this._currentActiveSlide : 0;\n        break;\n      case Direction.PREV:\n        // if this is first slide, not force, looping is disabled and need to going backward - select current slide, as a next\n        nextSlideIndex = (this._currentActiveSlide > 0) ? this._currentActiveSlide - 1 :\n          (!force && this.noWrap ) ? this._currentActiveSlide : this._slides.length - 1;\n        break;\n      default:\n        throw new Error('Unknown direction');\n    }\n    return nextSlideIndex;\n  }\n\n  /**\n   * Sets a slide, which specified through index, as active\n   * @param index\n   * @private\n   */\n  private _select(index: number): void {\n    if (isNaN(index)) {\n      this.pause();\n      return;\n    }\n    let currentSlide = this._slides.get(this._currentActiveSlide);\n    if (currentSlide) {\n      currentSlide.active = false;\n    }\n    let nextSlide = this._slides.get(index);\n    if (nextSlide) {\n      this._currentActiveSlide = index;\n      nextSlide.active = true;\n      this.activeSlide = index;\n      this.activeSlideChange.emit(index);\n    }\n  }\n\n  /**\n   * Starts loop of auto changing of slides\n   */\n  private restartTimer(): any {\n    this.resetTimer();\n    let interval = +this.interval;\n    if (!isNaN(interval) && interval > 0) {\n      this.currentInterval = setInterval(\n        () => {\n          let nInterval = +this.interval;\n          if (this.isPlaying && !isNaN(this.interval) && nInterval > 0 && this.slides.length) {\n            this.nextSlide();\n          } else {\n            this.pause();\n          }\n        },\n        interval);\n    }\n  }\n\n  /**\n   * Stops loop of auto changing of slides\n   */\n  private resetTimer(): void {\n    if (this.currentInterval) {\n      clearInterval(this.currentInterval);\n      this.currentInterval = void 0;\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  selector: 'carousel',\n  template: `\n    <div (mouseenter)=\"pause()\" (mouseleave)=\"play()\" (mouseup)=\"play()\" class=\"carousel slide\">\n      <ol class=\"carousel-indicators\" *ngIf=\"slides.length > 1\">\n         <li *ngFor=\"let slidez of slides; let i = index;\" [class.active]=\"slidez.active === true\" (click)=\"selectSlide(i)\"></li>\n      </ol>\n      <div class=\"carousel-inner\"><ng-content></ng-content></div>\n      <a class=\"left carousel-control carousel-control-prev\" [class.disabled]=\"activeSlide === 0 && noWrap\" (click)=\"previousSlide()\" *ngIf=\"slides.length > 1\">\n        <span class=\"icon-prev carousel-control-prev-icon\" aria-hidden=\"true\"></span>\n        <span *ngIf=\"isBs4\" class=\"sr-only\">Previous</span>\n      </a>\n      <a class=\"right carousel-control carousel-control-next\" (click)=\"nextSlide()\"  [class.disabled]=\"isLast(activeSlide) && noWrap\" *ngIf=\"slides.length > 1\">\n        <span class=\"icon-next carousel-control-next-icon\" aria-hidden=\"true\"></span>\n        <span class=\"sr-only\">Next</span>\n      </a>\n    </div>\n  `\n}, ] },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: CarouselConfig, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'noWrap': [{ type: Input },],\n'noPause': [{ type: Input },],\n'activeSlideChange': [{ type: Output },],\n'activeSlide': [{ type: Input },],\n'interval': [{ type: Input },],\n};\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}