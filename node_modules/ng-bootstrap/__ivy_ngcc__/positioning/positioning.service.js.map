{"version":3,"file":"positioning.service.js","sources":["../../src/positioning/positioning.service.ts"],"names":[],"mappings":"OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,MAAM,eAAe;AACtD,OAAO,EAAE,gBAAgB,EAAE,MAAM,kBAAkB;;AAkCnD;AACa,IADb;AAAgC,IA4BhC,CAAC;AACD,IA5BS,qCAAQ,GAAf,UAAgB,OAA2B;AAAI,QACtC,6BAAO,EAAE,uBAAM,EAAE,+BAAU,EAAE,mCAAY,CAAY;AAChE,QAAI,gBAAgB,CACd,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,EAC5B,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,EAC7B,UAAU,EACV,YAAY,CAAC,CAAC;AACpB,IAAE,CAAC;AAEH,IAAU,4CAAe,GAAvB,UAAwB,OAA0C;AAAI,QACpE,kCAAkC;AACtC,QAAI,EAAE,CAAC,CAAC,OAAO,OAAO,KAAK,QAAQ,CAAC,CAAC,CAAC;AACtC,YAAM,MAAM,CAAC,QAAQ,CAAC,aAAa,CAAC,OAAO,CAAgB,CAAC;AAC5D,QAAI,CAAC;AACL,QACI,EAAE,CAAC,CAAC,OAAO,YAAY,UAAU,CAAC,CAAC,CAAC;AACxC,YAAM,MAAM,CAAC,OAAO,CAAC,aAAa,CAAC;AACnC,QAAI,CAAC;AACL,QACI,MAAM,CAAC,OAAsB,CAAC;AAClC,IAAE,CAAC,CAGD;IAFK,JAGP,IAAA,kBAAkB;UAHD,GAA0B,UAC3C,EAAE,IAAI,EAAE,UAAU,EAAE,OACnB,lDAED,IAAO,iCAAc,GAAmE,cAAM,OAAA,EAC7F,EAD6F,CAC7F;;;;;gDAAC;AACF,IAAA,yBAAC;AAAD,CAAC,AA5BD,IA4BC;AACD","sourcesContent":["import { Injectable, ElementRef } from '@angular/core';\nimport { positionElements } from './ng-positioning';\n\nexport interface PositioningOptions {\n  /** The DOM element, ElementRef, or a selector string of an element which will be moved */\n  element?: HTMLElement | ElementRef | string;\n\n  /** The DOM element, ElementRef, or a selector string of an element which the element will be attached to  */\n  target?: HTMLElement | ElementRef | string;\n\n  /**\n   * A string of the form 'vert-attachment horiz-attachment' or 'placement'\n   * - placement can be \"top\", \"bottom\", \"left\", \"right\"\n   * not yet supported:\n   * - vert-attachment can be any of 'top', 'middle', 'bottom'\n   * - horiz-attachment can be any of 'left', 'center', 'right'\n   */\n  attachment?: string;\n\n  /** A string similar to `attachment`. The one difference is that, if it's not provided, `targetAttachment` will assume the mirror image of `attachment`. */\n  targetAttachment?: string;\n\n  /** A string of the form 'vert-offset horiz-offset'\n   * - vert-offset and horiz-offset can be of the form \"20px\" or \"55%\"\n   */\n  offset?: string;\n\n  /** A string similar to `offset`, but referring to the offset of the target */\n  targetOffset?: string;\n\n  /** If true component will be attached to body */\n  appendToBody?: boolean;\n}\n\n\nexport class PositioningService {\n  public position(options: PositioningOptions): void {\n    const {element, target, attachment, appendToBody} = options;\n    positionElements(\n      this._getHtmlElement(target),\n      this._getHtmlElement(element),\n      attachment,\n      appendToBody);\n  }\n\n  private _getHtmlElement(element: HTMLElement | ElementRef | string): HTMLElement {\n    // it means that we got a selector\n    if (typeof element === 'string') {\n      return document.querySelector(element) as HTMLElement;\n    }\n\n    if (element instanceof ElementRef) {\n      return element.nativeElement;\n    }\n\n    return element as HTMLElement;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}